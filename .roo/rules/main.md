# Chain://Research

## 核心工程标准操作程序 (SOP)

此 SOP 是管辖所有子项目（如 OSPU）中所有开发活动的通用法则。它源于 Chain://Research 项目的最佳实践，专为 Rust 项目设计。

### 零号优先级：从错误中学习

1. **先分析现有代码**：在编写或修改任何代码之前，我的第一个动作**必须**是分析相关项目目录中的现有代码库。我将识别并采用已建立的架构模式、编码风格和模块结构。
2. **证据优于假设**：所有行动都基于可验证的证据（文件内容、错误日志、测试结果）。假设是暂时的；当与证据冲突时，必须立即抛弃。
3. **复用先于构建**：在创建新功能前，我**必须**搜索并复用现有的函数、类和配置，绝不重复造轮子。
4. **外科手术式修改**：在修改上游库（如 `tfhe-rs`）时，我**必须**优先采用继承和覆写最小可能组件的方式，而不是重写庞大的方法。

### 第一优先级：代码与环境规范

5. **无注释，代码自解释**：代码必须简洁且自文档化。**禁止所有注释和文档字符串**。我将使用任何可用的语法糖来减少代码量，前提是能通过静态分析。
6. **严格的类型安全**：所有新代码**必须**包含完整且严格的类型注解。必须尽一切可能避免使用 `dyn Any` 类型。所有代码必须通过 `cargo check` 和 `cargo clippy` 检查。
7. **纯函数**：数据处理和计算逻辑必须设计为无副作用的纯函数。
8. **依赖管理**：**必须**使用 `cargo`。所有依赖项都应通过 `cargo add <crate>` 添加到 `Cargo.toml` 文件中。

### 第二优先级：工作流与验证

9. **测试驱动**：新功能或修复**必须**附带相应的单元测试，断言必须清晰明确。
10. **配置驱动**：所有主要脚本**必须**由配置文件（如 TOML 或 YAML）驱动。可执行脚本中禁止硬编码参数。
11. **强制静态分析**：每完成一个重要功能后，我**必须**运行 `cargo check; cargo clippy --fix --allow-dirty` 并确保所有检查通过。在修复静态分析错误之前，我会分析其根本原因，以避免更深层次的设计缺陷。
12. **失败升级**：如果测试或关键工作流连续三次失败，我**必须**暂停，报告失败日志和我的分析，并等待进一步指示。

## OSPU 特定工程准则

### 1. 核心目标

我们的核心目标是利用 **TFHE-rs** 库，在 Rust 中构建一个基于全同态加密（FHE）的**自主密钥管理状态机 (OSPU)**。此状态机将在加密域内实现密钥的自主管理、状态转换和策略执行，同时保证其逻辑状态的唯一性和因果完整性。

### 2. 项目结构

所有源代码将遵循标准的 Rust 项目结构，以确保代码的模块化和可维护性。

```
OSPU/
├── src/
│   ├── isa/          # 指令集架构 (LOAD, ADD, AnchorMatch 等)
│   ├── registers.rs  # 加密寄存器定义
│   ├── engine.rs     # FHE 操作引擎
│   └── main.rs       # 程序入口与 Host-OSPU 交互逻辑
├── tests/
│   ├── isa_tests.rs  # 指令集单元测试
│   └── e2e_flow.rs   # 端到端工作流集成测试
├── docs/             # 项目文档
├── Cargo.toml        # 项目依赖与配置
└── .clinerules/      # Cline 开发规则
```

### 3. 工程准则

- **语言与工具链**: **必须**使用 Rust 及其现代化的 `cargo` 工具链。利用 `tokio` 作为异步运行时处理与 Host 的通信。
- **代码风格**:
  - 严格遵循 Rust 官方命名约定 (`snake_case` for functions/variables, `PascalCase` for types)。
  - **无注释策略**: 代码必须自解释。移除所有既有注释，新代码通过清晰的命名和结构来表达意图。
- **核心原则**:
  - **安全优先**: 充分利用 Rust 的所有权、类型系统和内存安全保证，构建零信任环境下的可靠代码。
  - **模块化**: 将指令集、FHE 引擎、寄存器等核心关注点分离到独立的模块中。
  - **性能意识**: 在设计和编码时，始终将 FHE 操作的性能开销（特别是 PBS）纳入考量。
- **依赖管理**: 所有依赖项通过 `cargo add <crate>` 添加，并记录在 `Cargo.toml` 中。

### 4. FHE 实现指南 (基于 TFHE-rs)

- **数据表示**:
  - OSPU 内部所有加密寄存器（`CK_reg`, `INT_CTR_reg` 等）**必须**使用 `tfhe::integer::RadixCiphertext` 类型。
  - **参数选择**: 默认使用 `PARAM_MESSAGE_2_CARRY_2_KS_PBS` 参数集，以平衡整数运算的性能和噪声预算。确保所有交互的密文使用相同的加密参数。
- **指令集实现 (`src/isa/`)**:
  - 将 `README_ZH.md` 中定义的每条指令（`LOAD`, `ADD`, `CMP`, `MUX`, `AnchorMatch` 等）映射为一个独立的 Rust 函数。
  - 操作直接调用 `tfhe::ServerKey` 提供的同态运算方法。
  - 充分利用 `rayon` 对可以并行化的操作（如 `AnchorMatch` 中的多个比较）进行加速。
- **性能优化**:
  - **并行化**: 对于数据并行的 FHE 操作（例如对一个密文向量的每个元素应用同一函数），**必须**使用 `rayon` 的并行迭代器来利用多核 CPU。
  - **避免不必要的引导 (PBS)**: 深入理解 FHE 操作的噪声增长模型。在噪声预算允许的情况下，将多个操作链接在一起，以减少昂贵的 PBS 调用。
  - **算法优化**: 对于复杂的函数，研究如何将其分解为最少数量的 FHE 基础操作。
- **测试策略 (`tests/`)**:
  - **正确性验证**: 对每条指令的 FHE 实现进行单元测试，确保其加密计算结果与明文计算结果一致。
  - **噪声边界测试**: 设计测试用例，探索操作在临界噪声水平下的行为，确保其在预期的失败概率内运行。
  - **性能基准**: 为关键指令（`MUL`, `CMP`, `AnchorMatch`）编写基准测试，以跟踪和优化其性能。

### 5. 工作流

- **核心循环**: `分析需求 -> 编写/修改 src/ 代码 -> cargo test --all-features 验证 -> 提交`。
- **状态追踪**: 每完成一个重要功能模块（例如，`Base ISA` 的实现），就在 `.roo/rules/process.md` 中更新待办事项清单和关键发现。

## OSPU 开发路线图与状态追踪

### 阶段一: PoC 核心功能 (MVP)

- [ ] **任务 1**: 在 `src/registers.rs` 中定义所有加密寄存器结构。
  - [ ] **子任务 1.1**: 为所有寄存器统一定义类型别名 `type OSPUReg = tfhe::integer::RadixCiphertext;`。
  - [ ] **子任务 1.2**: 明确所有 `RadixCiphertext` 实例将使用 `PARAM_MESSAGE_2_CARRY_2_KS_PBS` 参数集。**理由**: 根据 `tfhe-rs-handbook` 的基准测试，此参数集在整数运算的性能和功能（如并行进位传播）之间提供了最佳平衡。
  - [ ] **子任务 1.3**: 定义一个结构体 `OSPURegisters` 来统一管理所有的寄存器实例。

- [ ] **任务 2**: 在 `src/isa/` 目录中，为每条基础指令（Base ISA）创建一个独立的模块文件。
  - [ ] **子任务 2.1 (ADD/SUB)**: 实现 `add.rs` 和 `sub.rs`。操作直接调用 `server_key.add()` 和 `server_key.sub()`。这些函数内部利用了高效的并行进位传播算法。
  - [ ] **子任务 2.2 (MUL)**: 实现 `mul.rs`。采用 Schoolbook 乘法算法。这将涉及一个嵌套循环，对操作数的每个块（digit）执行 `B*B` 次 `bivariate_pbs` 调用，然后高效地对部分积求和。
  - [ ] **子任务 2.3 (CMP/MUX)**: 实现 `cmp.rs` 和 `mux.rs`。操作直接调用 `server_key.eq()` 和 `server_key.if_then_else()`，它们是基于 PBS 的原子操作。
  - [ ] **子任务 2.4 (LOAD/OUT/INC_CTR)**: 实现 `load.rs`, `out.rs`, `inc_ctr.rs`。这些是线性操作，不涉及 PBS，噪声增长可控。

- [ ] **任务 3**: 实现特殊指令 `AnchorMatch` 和 `KeySwitch`。
  - [ ] **子任务 3.1 (AnchorMatch)**: 在 `src/isa/anchor_match.rs` 中实现。
    - [ ] **3.1.1**: 将 `AnchorMatch` 分解为两个并行的同态比较：`CMP(EXT_MR_reg, exp_mr)` 和 `CMP(INT_CTR_reg, exp_ctr)`。
    - [ ] **3.1.2**: 对两个比较操作返回的加密布尔结果，执行一次同态 `AND`（通过一次二元 PBS 实现）。
    - [ ] **3.1.3**: **[性能关键]** 两个并行的 `CMP` 操作必须使用 `rayon::join` 来执行，以最大化利用 CPU 核心，显著降低延迟。
  - [ ] **子任务 3.2 (KeySwitch)**: 在 `src/isa/key_switch.rs` 中实现。
    - [ ] **3.2.1**: PoC 阶段的 `KeySwitch` 实现为一个简单的 `LOAD` 操作，将新的 ClientKey 明文加载到 `NCK_reg`。实际的密钥切换逻辑由 Host 在 OSPU 外部通过状态重加密完成。

- [ ] **任务 4**: 编写完整的单元测试 (`tests/isa_tests.rs`) 和集成测试 (`tests/e2e_flow.rs`)。

- [ ] **任务 5**: 在 `src/main.rs` 中构建一个模拟 Host 与 OSPU 交互的命令行程序。

### 阶段二: 完整系统演进 (Future Work)

- [ ] **MPC 集成**: 研究并集成一个 Rust MPC 框架（如 `mpc-net`），以替代 PoC 中的明文密钥注入，实现分布式的 `KeySwitch`。
- [ ] **ZKP 状态验证**: 探索使用 Rust ZKP 库（如 `arkworks`）为 `AnchorMatch` 提供零知识证明，允许 Host 在不访问任何秘密的情况下验证状态转换的正确性。
- [ ] **硬件加速**: 评估并集成 `tfhe-rs-cuda` 后端，以利用 GPU 加速 FHE 计算。
- [ ] **物理安全集成**: 实现 DBRW 算法，将 OSPU 的加密状态与硬件指纹绑定。

### 关键发现与决策记录

- **决策 1 (核心数据结构)**: OSPU 的所有加密寄存器将基于 `tfhe::integer::RadixCiphertext` 实现，并统一采用 `2-bit message + 2-bit carry` 的块编码方案。此决策基于 `tfhe-rs-handbook` 的详尽性能分析，旨在最大化算术运算的效率。
- **决策 2 (性能优化策略)**: 所有数据并行的 FHE 操作（尤其是在 `AnchorMatch` 和 `MUL` 中）必须使用 `rayon` 库进行并行化，这是确保 OSPU 性能达到可接受水平的关键。
- **发现 1 (物理安全路径)**: `dbrw-pdf.md` 中描述的 DBRW (Dual-Binding Random Walk) 算法为 OSPU 实现物理抗克隆提供了具体的技术路线。它通过绑定硬件熵和环境指纹来防止状态机被复制。
- **发现 2 (架构理论基础)**: `dsm.md` 中描述的去中心化状态机 (DSM) 框架是 OSPU 设计哲学的理论基石。其"双边状态隔离"和"自验证状态演进"的核心思想，使 OSPU 能够摆脱对全局共识的依赖。
- **发现 3 (高级功能启发)**: DSM 框架中的"确定性 Limbo 保险库 (DLV)"概念——即延迟密钥派生——为未来设计完全在 FHE 加密域内执行的、有条件的、安全 `KeySwitch` 操作提供了重要启发。可以设想一个 FHE 电路，只有在 `AnchorMatch` 验证成功后，新密钥的解密密钥才能在 FHE 电路内部被计算出来。
